# 62.不同路径

[toc]

## 题目描述

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？





## 示例

**示例一：**

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

>```
>输入：m = 3, n = 7
>输出：28
>```

**示例 2：**

> 输入：m = 3, n = 2
> 	输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
>
> 1. 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向下
>



**示例3：**

```
输入：m = 7, n = 3
输出：28
```

**示例 4：**

```
输入：m = 3, n = 3
输出：6
```

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`





> 来源：力扣（LeetCode）
>
> 链接：https://leetcode-cn.com/problems/unique-paths
> 		著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。





## 题解：

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {

        // 根据加法原理，假设从S点的A方向到达Node 点有X重方式，从B方向到达Node点，有Y 种方式，那么从S点，到达Node 节点的方式就有 X + Y 种，

        // 因为我们可以从两个方向行动，所以我们需要二维数组来记录到达的每个点能够有多少种方式才行

        int f[m][n] ;

        // 初始化状态：因为在起始点的时候，只能有一种方式到达起始点
        f[0][0] = 1 ;

        // 对于在边界位置的点，我们只能朝一个方向一直前进才能到达所以：对于 (0...i-1 ,0) = 1 , (0,0...j -1) =1 

        // 初始化做边界状态    
        for(int i = 0 ; i < m ; ++i){
            f[i][0] = 1 ;
        }

        // 初始化右边界状态
        for(int j = 0 ; j < n ;++j){
            f[0][j] = 1 ;
        }


        // 状态转移方程 f[i][j] = f[i -1][j] + f[i][j-1] ;

        for(int i = 1; i < m ; ++i){
            for(int j = 1 ; j < n ;++j){
                f[i][j] = f[i -1][j] + f[i][j -1] ;
            }
        }

        return f[m -1][n-1] ;

    }
};
```



