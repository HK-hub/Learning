# 初学JVM

[toc]

# JVM 虚拟机生命周期

jvm虚拟机声明周期主要分为以下几部分：

- 虚拟机的启动
- 虚拟机的执行

- 虚拟机的退出





## 虚拟机启动

Java 虚拟机的启动是通过引导类加载器(bootstrap class loader) 创建一个初始类(initial class) 来完成的，这个类由虚拟机的具体实现来指定的。



## 虚拟机的执行



## 虚拟机的退出





# JVM 虚拟机发展历程

- Sun Classic VM 
    - 这款虚拟机内部只提供解释器，如果使用`JIT`编译器，就需要进行外挂。但是一旦使用了`JIT`编译器，`JIT`就会接管虚拟机的执行系统。解释器就不再工作，解释器和编译器不能配合工作。现在的`hotspot`虚拟机内置了此虚拟机。
- Exact VM 
    - `Exact Memory Management `准确式内存管理：此虚拟机可以知道内存中某个位置的数据的具体类型。
    - 具备现代高性能虚拟机的雏形：
        - 热点探测
        - 编译器与解释器混合工作模式
- HotSpot VM
    -  
- JRockit  VM
    - 专注于服务器端使用，不太关注程序的启动时间，因此`JRockit` 内部不包含解释器实现，全部代码都靠及时编译器编译后执行。
- J9 VM
    - 2017 年左右，IBM 发布了开源`J9 VM`，命名为`OpenJ9` ，交给Eclipse 基金会管理。
- Azul VM 
    - `Azul VM虚拟机`是 Azul System 公司在 HotSpot基础上进心大量改进，运行与其公司的专有硬件`Vega`系统上的Java虚拟机。
    - 每个`Azul VM` 实例都可以管理至少数十个CPU和数百个GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾回收器，专有硬件优化的线程调度等优势特性。
- Taobao VM
    - 阿里巴巴团队基于 `Open HotSpot VM` 开发的一款高性能的服务区虚拟机，传造型的`off-heap` 技术，将生命周期较长的Java 对象中堆中移到堆外，可以有效提升jvm 虚拟机的垃圾回收效率和速度。 

- Graal VM
    - `Graal VM` 在`HotSpot VM` 的基础上增强而成的**跨语言全栈虚拟机，可以作为任何语言的运行平台使用。**语言包括：Java，Python，Groovy, Kotlin，C，C++，JS，Ruby，Scala等
    - 支持不同语言中混用对方的接口和对象，支持这些语言使用已经编译好的本地库文件
    - 工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转化为能够`Graal VM`接受的中间表示。`Graal VM` 提供 `Truffle`  工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。



# JVM虚拟机内存结构





# 类加载子系统

## 类加载子系统的作用

![image-20220119134950036](C:\Users\HK意境\AppData\Roaming\Typora\typora-user-images\image-20220119134950036.png)

- 类加载子系统负责从文件系统或网络中加载Class 字节码文件，class文件在文件开头有特定的文件标识。

- `ClassLoader` 只负责class 文件的加载，至于它是否可以运行，则由`Execution Engine` 执行引擎决定。

- 加载的类信息存放于一块称为**方法区**的内存空间，除了类信息外，`方法区`还会存放运行时常量池信息，可能还包括字符串字面量和数字常量(这部分常量信息是来自于`Class`字节码文件中的**常量池部分**的内存映射)

    ![image-20220119135636005](https://s2.loli.net/2022/01/19/uGaIdyjzgLrnsXq.png)



## 类加载器ClassLoader角色

`Class Loader` 类加载器负责把Class 字节码文件加载进入内存，放入`方法区`。当这个class 文件加载到`JVM` 中，被称为 `DNA元数据模板`，放在方法区；在class 字节码文件 ——> JVM ——> 元数据模板，此过程需要一个运输工具，这个对应的运输工具就是`类加载器Class Loader` 

![image-20220119140621057](https://s2.loli.net/2022/01/19/LXbgmsIoyFDhMvu.png)



## 类加载过程

类的加载过程大致可以分为三个过程：`加载Loading` ——> `链接Linking` ——> `初始化Initialization` 

![image-20220119140912865](https://s2.loli.net/2022/01/19/MgyzR6dbAVko9HN.png)

### 加载Loading 阶段

1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的**静态存储结构**转换为方法区的**运行时数据结构**
3. 在内存中生成一个代表这个类的`java.lang.Class` 对象，作为方法去这个类的各种数据的访问入口。

> 补充：加载 .class 字节码文件的方式
>
> - 从本地系统中直接加载
> - 通过网络获取：典型的场景例如 Web Applet
> - 从 zip 压缩包中读取，成为日后 jar ,war 格式的基础
> - 从加密文件中获取
> - 运行时计算生成，使用最多的是：动态代理技术
> - 有其他文件生成：典型的场景例如  JSP 应用
> - 从专用数据库中提取 .class文件



### 链接Linking 阶段

链接阶段中主要包括三个步骤，需要做三件事情：**验证Verif ，准备Prepare ，解析Resolve**

**验证Verif：**

- 确保`Class`字节码文件的字节流包含信息符合当前虚拟机的要求，保证类加载的正确性，不会危害虚拟机自身安全。
- 主要包括4钟验证方式：文件格式验证，元数据验证，字节码验证，符号引用验证

**准备Prepare：**

- 为**类变量(静态变量)**分配内存并且设置该类变量的值为**默认初始值**。
- 这里不包含`final` 修饰的类变量，因为`fianl`修饰的属性已经是**常量**了，常量在编译时就会分配了，在**加载阶段**就会显示初始化；
- 类变量会分配在方法区区中，而实例变量会随着对象一起被分配到**Java堆中**

**解析Resolve：**

- 将字节码文件中的常量池内的符号引用转换为直接用户的过程。



### 初始化 Initialization阶段：









## 类加载器ClasssLoader

### 类加载器分类

- JVM支持两种类型的类加载器，分别为`引导类加载器Bootstrap ClassLoader` 和`自定义类加载器User-Defined ClassLoader` 。

![image-20220119162214473](https://s2.loli.net/2022/01/19/w1UfoWJs8thagck.png)

- 将所有派生于抽象类 `ClassLoader` 的类加载器都划分为自定义类加载器：
    - 这其中包括典型的 `扩展类加载器ExtendClassLoader`和`应用程序类加载器AppClassLoader` 都是继承于 **抽象类加载器**



### 虚拟机自带的加载器

- **引导类加载器Bootstrap ClassLoader：**

    - 这个类加载器使用`C/C++` 语言进行实现的，嵌套在 JVM 内部，无法通过`getClassLoader()`等方式获取到其对象实例。
    - 引导类加载器`Bootstrap ClassLoader` 用来**加载 Java 的核心类库**(JAVA_HOME/**jre/lib 路径**下的内容)，用于提供JVM自身需要的类。
    - 并不继承自 `java.lang.ClassLoader` 类，没有父加载器。
    - **用于加载扩展类和应用程序类加载器，并指定为他们的父类加载器**
    - 处于安全考虑，`Bootstrap ClassLoader`引导类加载器只加载包名为 java, javax, sun 等开头的类。

    

- **扩展类加载器Extension ClassLoader：**

    - Java 语言编写，**继承于 `ClassLoader 抽象类` ，父类加载器为启动类加载器**。

    - **加载 java.ext 目录下的类库**，或从JDK的安装目录 jre/lib/ext (**扩展目录**)下加载类库。**如果用户创建的 JAR 包放在此目录下，也会由扩展类加载器加载。**

        

- **应用程序类加载器App ClassLoader：**
    - Java 语言编写，**继承于 `ClassLoader 抽象类` ，父类加载器为扩展类加载器**。
    - **负责加载 `classpath` 或系统属性`java.class.path`指定路径下的类库。**
    - 应用程序类加载器是**默认的类加载器**，一般来说，Java应用的类都是由它来完成加载。





### 自定义类加载器

**为什么要自定义类加载器：**

- 隔离加载类
- 修改类的加载方式
- 扩展加载源
- 防止源码泄漏

实现**按需加载，动态加载**



**自定义类加载器的步骤：**

​	如果用户需要自定义类加载器，只需要**继承`ClassLoader`抽象类**，并且重写其`loadClass()`或者`findClass()` 方法即可，但是这样做实现过程将会比较复杂，所以也可以**简单的继承`URLClassLoader类`** 。

![image-20220119192501756](https://s2.loli.net/2022/01/19/13wntxXNIflu2aS.png)



### 获取ClassLoader的方式

可以通过以下几种方法获取到 ClassLoader 对象：

- 通过 Class 对象 getClassLoader() 方式获取

    ```java
    ClassLoader classLoader = GetClassLoaderTest.class.getClassLoader();
    ClassLoader classLoader = Class.forName("String").getClassLoader();
    ```

- 通过当前线程的线程上下文环境获取ClassLoader 对象

    ```java
    // 方式二：通过当前线程的线程上下文类加载器
    ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    ```

- 直接通过ClassLoader类获取到系统类加载器，然后可以通过 getParent() 获取父类加载器

    ```java
    ClassLoader extClassLoader = ClassLoader.getSystemClassLoader().getParent();
    ```

    



### 双亲委派机制

 Java 虚拟机对 `.class` 字节码文件的加载是**按需加载**的, 当需要用到该类时，才会将他的 `.class`文件加载到内存，生成 class 对象。而且加载某个class 文件的类时，Java虚拟机会把请求先交给父类加载器处理，如果父类加载器能够加载到该类的 `.class`文件时则加载成功返回结果；如果父类加载器不能完成加载任务之类才会尝试自己去加载。

![image-20220119195641058](https://s2.loli.net/2022/01/19/PJ4do7unZmz8YGa.png)

**工作原理：**

1. 如果一个类加载器收到类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行；
2. 如果父类加载器还存在父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的类加载器；
3. 如果父类加载器可以完成类加载任务，就成功放回；如果不能完成此加载任务，子类加载器才会自己尝试去加载。



**优势：**

- **保证类不会被重复加载。**
- 保护程序安全，防止核心API 被篡改。





## 沙箱安全机制

安全机制

## 类的使用

类的主动使用，类的被动使用



# 运行时数据区

当字节码文件经过了类加载子系统进行加载，链接，初始化之后，就会将其放入内存中；然后我们的执行引擎就能够使用运行时数据区中的数据，对象，资源等；资源，数据，对象等使用完成后，会有垃圾回收器来进行垃圾回收。

![image-20220120201354047](https://s2.loli.net/2022/01/20/iwp3duWFZqbKhzj.png)

内存是非常重要的系统资源，是硬盘和CPU 之间的桥梁，承载着操作系统和应用程序之间的实时运行，**JVM 内存布局** 规定了Java在运行过程中的内存申请，分配，管理的策略，保证了JVM的高效稳定。不同的JVM虚拟机对内存的划分和管理机制存在部分差异。接下来我们探讨一下经典的JVM虚拟机内存布局。



## 运行时数据区的布局

**运行时数据区(Run time Data Area) **主要有以下几部分构成，当然不同的划分方式可能存在部分差异：

![image-20220120204706521](https://s2.loli.net/2022/01/20/vZ8HO3RGIP5JrKg.png)

- 本地方法栈(Native Method Stacks)
- 程序计数器(Program Counter Register)
- 虚拟机栈(JVM Stacks)
- 堆区(Heap Area)
- 堆外内存**(方法区)**：其实这一部分指的就是**方法区**，是指除了以上的划分部分后剩余的部分分区，不同的划分差异也便存在于此，又可以具体分为：
    - 元空间(Metaspace) : 此空间和下面的几个部分合合起来称为是`方法区`的实现，而方法区则是规范。
    - 代码缓存(CodeCache) ：这一部分是 JIT编译后的产物。 

![image-20220224200120932](https://s2.loli.net/2022/02/24/dLauYGoOQiXreP8.png)

Java 虚拟机定义了若干种程序运行时期间会使用到的运行时数据区，其中一些会伴随着虚拟机的启动，退出而创建和销毁。另外一些则是与线程一一对应，这些与线程一一对应的数据区会随着线程的开始和结束而一起创建和销毁。

**运行时数据区中线程共享的部分为**：

- 堆区
- 方法区

运行时数据区中每个线程独有的部分：

- 程序计数器PC
- 虚拟机栈
- 本地方法栈



## 程序计数器 PC

JVM 中的 `PC寄存器`是对物理程序计数器的一种**抽象的软件模拟**，`PC 寄存器`用来存储将要执行的下一条指令的地址，也即将要执行的下一条指令代码，将其地址读取到寄存器中存储后，由执行引擎读取执行。

- `PC 程序计数器`是一块很小的内存，几乎可以忽略不计，也是运行速度最快的存储区域。
- 在 JVM 规范中每个线程都有自己的PC程序计数器，是**线程私有**的，生命周期与线程**生命周期保持一致**。
- 任何时间，都只有一个方法在线程中执行，也就是所谓的**当前方法**，程序计数器PC 会存储当前线程正在执行的Java 方法的 JVM 指令地址，如果是执行**`native` 方法则不需要指定线程PC 的值，此时PC的值为未指定值(undifined)。**





## 虚拟机栈 JVM Stacks

###  虚拟机栈概述

**虚拟机栈出现背景**：

​	由于跨平台的性的设计，**Java 的指令都是基于栈**来进行设计的。不同平台，CPU 架构不同，所以不能设计为基于寄存器的。

`jvm`虚拟机使用基于栈的指令系统，可以具有**跨平台，指令集小，编译器容易**实现的优点，但是缺点是**性能下降**，实现同样的功能需要更多的指令。

**虚拟机栈基本内容：**

​	**栈是运行时的单位，而堆是存储时的单位。**栈解决程序的运行问题，即程序如何执行，数据如何处理。堆解决的是数据如何存储，何时存储的问题。

![image-20220122191128231](https://s2.loli.net/2022/01/22/cRgSAXz6e1wUouE.png)



**Java 虚拟机栈：**

​	`jvm stack` 虚拟机栈，每个线程在创建时都会创建一个对应的`虚拟机栈` ，这个虚拟机栈是**线程私有**的，其内部是一个个的`栈帧stack frame` , 每个栈帧分别都对应一个个的 Java 方法调用。**虚拟机栈的生命周期和其对应的线程是一致的**，随着线程的创建销毁而相应的生成，消失。



**虚拟机栈的作用：**

​		主管 Java程序的运行，它**内部的保存方法的局部变量，部分结果，并参与方法的调用和返回**。



**虚拟机栈的优点：**

- `栈`是一种快速有效的存储分配方式，访问速度仅次于程序计数器PC。
- JVM 直接对虚拟机栈的操作只有`入栈`和`出栈`两个：每个方法执行时就入栈，方法结束就出栈。
- **对于栈来说不存在垃圾回收问题**。



> 注意：Java 虚拟机规范规定**虚拟机栈的大小可以是动态的和固定不变的**：
>
> ​			～ 如果采用**固定大小**的 Java 虚拟机栈，哪每一个Java虚拟机栈的大小可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过虚拟机栈容许的最大容量，则会抛出 **Stack Overflow Erro**r 异常
>
> ​			～ 如果Java虚拟机栈可以**动态扩展**，并且在尝试扩展的时候，无法申请到足够的内存，或者在创建新线程时没有足够的内存去创建虚拟机栈，那么 Java 虚拟机将会抛出 **OutOfMemoryError** 异常。 
>
> 
>
> 设置虚拟机栈的大小：使用参数 **-Xss** 选项来设置线程的最大栈空间。





### 栈的存储单位

`虚拟机栈`中是存放的是一个个的`栈帧` ，这些栈帧又由以下几部分组成：局部变量表，操作数栈，动态链接，方法返回地址以及一些附加信息。

![image-20220123190926736](https://s2.loli.net/2022/01/23/LIZtNhUkPX7OVbl.png)

如图所示表示为每个方法对应的栈帧的组成结构。





## 动态链接

**指向运行时常量池方法的引用**，将字节码文件中的`Constant Pool常量池`中的方法的符号引用转换到方法的直接引用。

![image-20220123192655020](https://s2.loli.net/2022/01/23/6nQpKF4VkNwRJc5.png)



## 堆区







## 方法区

### 栈，堆，方法区的关系

方法区是属于运行时数据区的：

![image-20220224105109684](https://s2.loli.net/2022/02/24/JlgI72shRaBrbLi.png)

Java 虚拟机栈中的本地变量表，存放有**指向堆区中对象实例的符号引用**，而我们的堆区的实例对象内部又存放着**对象类型(Class 类型)数据的指针**，指向**方法区**中的对象类型数据区域。

![image-20220224105844288](https://s2.loli.net/2022/02/24/gLznZtRNFiDspMy.png)

如上图所示，`Person 类`类型数据信息，是存放在`方法区`的 , `person`实例变量名存放于Java虚拟机栈，`new Person()` 则将实例对象分配到堆区，<u>Java 堆区，虚拟机栈，方法区的交互关系如下图：</u>

![image-20220224110146054](https://s2.loli.net/2022/02/24/CNbAJyogMDH3mUd.png)



### 方法区的理解

方法区包括了类加载的所有信息。从线程共享的角度看方法区：方法区是被所有JVM线程所共享的。

![image-20220224105409385](https://s2.loli.net/2022/02/24/NwCUuhqmTsK17bZ.png)

<u>元空间和永久代都是方法区的实现</u>：在 JDK 1.8 以前将永久代作为方法区使用，而在 JDK 1.8 以后，将永久代改为了元空间(元数据区)，此时的元空间也就是方法区的实现。元空间和永久代的本质是类似的，但是他们最大的区别在于：元空间不再虚拟机设置的内存中，而是使用本地内存。元空间的内部结构也进行了相应的调整。

 

### 设置方法区大小与OOM

### 方法区的内部结构

方法区中包含：对象数据类型，运行时常量池。

几种在常量池内存中存储的数据类型包括：

- 数量值
- 字符串值
- 类引用
- 字段引用
- 方法引用

这部分字节码常量池中的数据，在类加载到内存中后存放到方法区的运行时常量池中。

### 方法区使用举例

### 方法区的细节

 

### 方法区的垃圾回收

《Java虚拟机规范》对于方法区的垃圾回收并没有严格的要求，不同的虚拟机实现，甚至不同的版本对于方法区的垃圾回收支持都是不同的：有些 JVM 虚拟机甚至没有对方法区提供垃圾回收机制，而有些虚拟机对于方法区的垃圾回收执行效果并不是很友好。

方法区的垃圾回收的主要内容就是：类卸载，废弃的常量这两部分。但是需要实现方法区的垃圾回收的条件却非常苛刻，这里以类卸载为例子：如果需要实现一个类的卸载回收，那么这个类`Class` 对象就需要满足一下三个条件：

- 所有的类实例对象都已经被回收
- 加载类的类加载器也已经被回收
- 内存中有关Class类对象的引用全部被回收，并且不能再通过反射的方式去访问Class 类对象了。



## 直接内存布局

### 对象的实例化

**创建对象的方式：**

- new 对象
- 反射方式：Class 类的 newInstance() 方法
- Constructor构造器的 newInstance(Xxx) 方法
- 使用 Clone()
- 使用反序列化
- 第三方库Objenesis



**对象创建的步骤：**

1. 判断对象的类是否被加载，链接，初始化
2. 为对象分配内存
3. 处理并发安全问题：
    - 采用`CAS ` 失败重试，区域加锁保证更新的原子性
    - 每个线程分配一块 `TLAB`
4. 初始化分配到的空间：所有属性设置默认值，保证对象的实例字段在不赋值时可以直接使用
5. 设置对象的对象头
6. 执行` <init>` 方法进行初始化

### 对象的内存布局

![image-20220225205107788](https://s2.loli.net/2022/02/25/jrJcDBG2X9saA3v.png)

![image-20220225214422423](https://s2.loli.net/2022/02/25/5XQ6eTbsuHgcFmz.png)



### 对象的访问定位



## 直接内存

- 直接内存不是`JVM `虚拟机运行时数据区中的一部分，也不是《Java虚拟机规范》中定义的内存区域。

- 直接内存是在 Java堆外的，直接向操作系统申请的内存空间。

- 来源于 `NIO` ，通过存在堆中的DirectByteBuffer操作Native本地内存

- 通常，访问直接内存速度会优于访问 Java 内存，读写性能高：

    - 出于性能考虑，频繁的读写的场合，使用直接内存更加合理
    - Java 的NIO库运行程序使用直接内存，用于数据缓冲区。

- 直接内存也可能导致 OutOfMemoryError异常

- 直接内存的缺点：

    - 分配成本较高
    - 不受JVM内存回收管理

    



# 执行引擎

## JIT 即时编译器

![image-20220226105834387](https://s2.loli.net/2022/02/26/X85lNJ1IegodrWi.png)



## 热点代码及探测方式

![image-20220226110430255](https://s2.loli.net/2022/02/26/8EDjUmHCIzngrA2.png)



![image-20220226110647966](https://s2.loli.net/2022/02/26/V9xtk5W41g2SwlQ.png)



## 方法调用计数器

Invocation Counter 方法调用计数器：

![image-20220226110920688](https://s2.loli.net/2022/02/26/CHgGslqUQKjd8vm.png)

### 方法调用计数器执行原理

![image-20220226111314614](https://s2.loli.net/2022/02/26/98JPvKoEIARtwsj.png)





## 热度衰减

![image-20220226111458003](https://s2.loli.net/2022/02/26/7hA53vlpRfzn1YS.png)



## HotSpotVM中 JIT 分类

![image-20220226112814080](https://s2.loli.net/2022/02/26/iFV1BfdD8ot3m67.png)



### C1和C2 的优化策略

![image-20220226113027820](https://s2.loli.net/2022/02/26/cg5QCUSO94fYAF1.png)



## AOT 编译器

![image-20220226113506572](https://s2.loli.net/2022/02/26/VAW1nxObKQHYF92.png)

![image-20220226113808206](https://s2.loli.net/2022/02/26/VRfJ1qO7eMnGAvr.png)





# StringTable

## String的基本特性

![image-20220226133854020](https://s2.loli.net/2022/02/26/GLVy6rK3F8sUxTl.png)

<img src="https://s2.loli.net/2022/02/26/JVrOHS3Fgkzys7E.png" alt="image-20220226140955316"  />

结合上面的分析，关于值传递和引用传递可以得出这样的结论：

**（1）基本数据类型传值，对形参的修改不会影响实参；**
    	**（2）引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改会影响到实际的对象；**
        **（3）String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后的操作不会修改实参对象。**



**String 的不可变性：**

- 字符串常量池中不会存储相同内容的字符串

![image-20220226141835664](https://s2.loli.net/2022/02/26/gInaN2C4wYGkjlT.png)



## String的内存分配

字符串常量池是分配存储在堆区的，

## String的基本操作

## 字符串拼接操作

1. 常量与常量，或者是常量引用之间的组合拼接的拼接结果保存在常量池中，原理是编译期优化
2. 字符串常量池中不会存在相同内容的常量
3. 只要其中那个一个是变量，结果就在堆中(非常量池区域) new String() ，具体的内容为拼接的结果。变量拼接的原理是StringBuilder：
    - 变量参与的字符串拼接过程细节如下：
        - StringBuilder sb = new StringBuilder();
        - sb.append(a)
        - sb.append(b)
        - sb.toString()  ——> 类似于 new String() 
4. 如果拼接的结果调用 intern() 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此字符串对象地址。



**效率问题：**

通过 StringBuilder 的 append() 方式拼接字符串的效率要远高于使用String 的字符串拼接的方式！

- StringBuilder 的append() 方式：自始自终只会创建一个StringBuilder 对象，而且toString() 也只会在调用一次。

- 使用String的字符串拼接方式：内存中创建了较多的StringBuilder 对象和 String 对象，内存占用更大；如果进行GC的话，还需要花费额外的时间。



## intern() 的使用

`String.intern()` 方法表示如果字符串常量池中没有对应的 data 的字符串，那么则在常量池中生成，并且返回生成的字符串常量的地址。





## StringTable 的垃圾回收

使用 intern() 方法可以大大减少 String 对象在 堆区中的对象实例数，和所占的内存空间





## G1 中的String去重操作

![image-20220226164855434](https://s2.loli.net/2022/02/26/2PgQITJEraCpnAu.png)

![image-20220226165115404](https://s2.loli.net/2022/02/26/qgMWeVmtoCTnDQN.png)



# GC 垃圾回收器

## 垃圾回收的时间

![image-20220301192336797](https://s2.loli.net/2022/03/01/LIK1oS9px4NcAhe.png)



![image-20220301193718011](https://s2.loli.net/2022/03/01/fjGkrSFihd24wYn.png)



## GC Roots

![image-20220301205431399](https://s2.loli.net/2022/03/01/hfg9YUzRMnEmper.png)





经典垃圾回收器组合关系：

 ![image-20220302211936209](https://s2.loli.net/2022/03/02/SCpgw4NeMmhXq9O.png)

