# Java 中的 IO 流

[toc]

# IO 流分类

- 按照流的流向分，可以分为输入流和输出流；
- 按照单位操作划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

Java Io 涉及 40 多个类，看起来这些类很杂乱，但实际上很有规律，而且 Java I0 之间存在非常多的流类，而且 Java Io 的 40 多个类都是从 4 个类基类中派生出来的。

- InputStream/Reader：所有的基类流，原来是字节输入流，是一个输入流。
- OutputStream/Writer：所有输出流的基类，是字节输出流，前面是字符输出流。



按操作方式分类结构图：

![IO-操作方式分类](https://s2.loli.net/2022/03/01/sPYSHzt1D4UdZJX.jpg)

按操作对象分类结构图：

![IO-操作对象分类](https://s2.loli.net/2022/03/01/gFiPyaA8DG63V9J.jpg)

# 字节流与字符流

原想问：**不管是文件写入问题还是网络发送接收，都是字节的存储单元，那I/O流操作要分成字节流操作和字符流操作呢？**

回答：字符编码是由Java虚拟机转换得到的，问题在这个字符上就很容易出现，并且如果我们编写编码类型就很容易出现。所以，I/O 问题很容易出现干脆提供了直接操作字符的接口，方便我们平时用一个字符对字符进行操作。



# BIO，NIO，AIO

- **BIO (Block I/O):**同步阻止 I/O 模式，数据写入必须在一个线程内阻止。是比较优秀的，可以让一个用于自己的系统的问题，并且测试模型用过多考虑系统的简单/流畅的连接处理能力，也不用担心连接池本身就是一个天然的斗斗，可以缓冲一些系统但是，当面对十万甚至百万连接的时候，传统的 BIO 模型是无功率级的。因此，需要更高效的 I/O 处理模型来增加我们的量度。
- **NIO（Non-blocking/New I/O）：** NIO是一种同步非阻塞的I/O模型，在Java 1.4中引入了NIO框架，对java.nio包，提供了Channel、Selector、Buffer等抽象。 NIO 中的 N 非阻塞，不完全是新的。它可以支持缓冲的，基于的 I/ O操作`Socket`方法。通道都支持抑制和非抑制性模式。但就像中型的使用抑制和抑制模式，比较简单，一般和传统类型都不好；非性能模式也比较适合。低、低的应用程序，可以使用动态激励 I/O 来开发网络和改进的维护；以更高的比例、更高的应用性（应用性）来应用，使用 NIO 的非抑制模式来`ServerSocket``SocketChannel``ServerSocketChannel`
- **AIO（异步I/O）：** AIO NIO 2。在Java 7中NIO的改进版NIO 2，负载也是异步了非的IO模型。异步IO是基于事件和机制实现的，也就是应用它AIO是同时在操作网络中提供了非IO操作的标题，在操作中提供了非操作的方法， NIO，对于NIO来说，对于业务线程是在IO准备好的时候，通知我们，接下来由这个线程自己进行IO操作，IO操作就本身是同步相关的。网上资料的。 ，我发现就目前而言 AIO 的应用还不是很广泛，Netty 之前试用过使用 AIO，不过放弃了。





# 深拷贝 vs 浅拷贝

1. **浅拷贝**：对基本数据类型值传递，对引用类型进行拷贝上传的拷贝，以此为浅拷贝。
2. **深拷贝**：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。

![深浅拷贝](https://s2.loli.net/2022/03/01/OeaTFwhGAloRUMP.jpg)

